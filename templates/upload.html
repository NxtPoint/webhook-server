<form id="uploadForm" enctype="multipart/form-data">
  <input type="email" name="email" placeholder="Your email" required />
  <input type="file" name="file" accept=".mp4,.mov,video/*" required />
  <button type="submit">Upload to Our Dropbox & Analyze</button>
</form>

<script>
  const form = document.getElementById("uploadForm");
  const statusText = document.getElementById("status");
  const subtasksEl = document.getElementById("subtasks");
  const spinner = document.getElementById("spinner");
  const progressFill = document.getElementById("progressFill");
  const MAX_MB = parseInt(document.querySelector(".container").dataset.maxMb || "150", 10);
  const MAX_BYTES = MAX_MB * 1024 * 1024;

  function updateProgressBar(p){ progressFill.style.width = p + "%"; }
  function updateStatus(m){ statusText.innerText += (statusText.innerText ? "\n" : "") + m; }
  function renderSubtasks(obj){
    if (!obj || typeof obj !== 'object') { subtasksEl.innerHTML = ""; return; }
    try { subtasksEl.innerHTML = `<strong>Subtask progress:</strong><code>${JSON.stringify(obj, null, 2)}</code>`; }
    catch { subtasksEl.innerHTML = ""; }
  }

  async function readJson(res){
    const txt = await res.text();
    try { return JSON.parse(txt); } catch { return { _raw: txt }; }
  }

  form.addEventListener("submit", async (e) => {
    e.preventDefault();
    statusText.innerText = "üöÄ Starting upload...";
    subtasksEl.innerHTML = "";
    updateProgressBar(5);
    spinner.style.display = "block";

    try {
      const fd = new FormData(form);
      const f = form.querySelector('input[type="file"]').files[0];
      if (!f) { updateStatus("‚ùå Please select a video file."); spinner.style.display="none"; updateProgressBar(0); return; }
      if (f.size > MAX_BYTES) {
        updateStatus(`‚ùå File is ${Math.round(f.size/1024/1024)}MB > ${MAX_MB}MB (server limit). Try a smaller clip.`);
        spinner.style.display="none"; updateProgressBar(0); return;
      }

      // POST to the legacy alias (/upload) which maps to /upload/api/upload
      const res = await fetch("/upload", { method: "POST", body: fd });
      const data = await readJson(res);

      if (!res.ok || data?.error) {
        const msg = data?.error || `HTTP ${res.status} ${res.statusText}: ${(data?._raw||"").slice(0,400)}`;
        updateStatus(`‚ùå Upload Error: ${msg}`); spinner.style.display="none"; updateProgressBar(0); return;
      }

      const taskId = data?.task_id || data?.sportai_task_id;
      if (!taskId) { updateStatus("‚ùå No task id returned."); spinner.style.display="none"; return; }

      updateProgressBar(40);
      updateStatus("‚úÖ Uploaded to our Dropbox and registered with SportAI...");
      if (data.share_url) updateStatus(`üìé Dropbox share: ${data.share_url}`);
      if (data.video_url) updateStatus(`üîó Direct video link: ${data.video_url}`);
      updateStatus("üì° Waiting for analysis to complete...");

      poll(taskId);
    } catch (err) {
      updateStatus(`‚ùå Final step failed: ${String(err)}`);
      spinner.style.display = "none";
    }
  });

  async function poll(taskId){
    let attempts = 0, maxAttempts = 120, delay = 5000;
    const timer = setInterval(async () => {
      attempts++;
      try {
        // FIX: call the correct backend route
        const res = await fetch(`/upload/api/task-status?task_id=${encodeURIComponent(taskId)}`);
        const data = await readJson(res);

        if (!res.ok || data?.error) {
          updateStatus(`‚ùå Poll error: ${data?.error || res.status}`);
          clearInterval(timer); spinner.style.display="none"; return;
        }

        // Backend returns: { ok, status, result_url, raw }
        const status = data.status || (data.raw && data.raw.status) || "unknown";
        const resultUrl = data.result_url || (data.raw && data.raw.result_url) || null;

        // Best-effort subtask/progress display if SportAI includes it
        const raw = data.raw || {};
        const pct = typeof raw.task_progress === "number" ? Math.round(raw.task_progress * 100) : (status === "completed" ? 100 : 0);
        updateProgressBar(Math.max(0, Math.min(100, pct)));
        renderSubtasks(raw.subtask_progress || raw.total_subtask_progress || null);

        if (status === "completed") {
          updateProgressBar(100);
          updateStatus("‚úÖ Analysis complete! (ingest follows via callback)");
          if (resultUrl) updateStatus(`üìÑ Result JSON: ${resultUrl}`);
          clearInterval(timer);
          spinner.style.display = "none";
        } else if (status === "failed") {
          updateStatus("‚ùå Analysis failed. Please try another video.");
          clearInterval(timer);
          spinner.style.display = "none";
        } else if (attempts >= maxAttempts) {
          updateStatus("‚ö†Ô∏è Timeout. Try again later.");
          clearInterval(timer);
          spinner.style.display = "none";
        } else {
          updateStatus(`üîÑ Status: ${status}${pct ? ` (${pct}%)` : ""}`);
        }
      } catch (err) {
        updateStatus(`‚ùå Polling failed: ${String(err)}`);
        clearInterval(timer);
        spinner.style.display = "none";
      }
    }, delay);
  }
</script>
